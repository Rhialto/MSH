; $Id: device1.a,v 1.51 92/04/17 15:41:30 Rhialto Rel $
; $Log: device1.a,v $
; Revision 1.51  92/04/17  15:41:30  Rhialto
; Freeze for MAXON3.
;
; Revision 1.46  91/10/06  18:25:18  Rhialto
;
; Freeze for MAXON
;
; Revision 1.42  91/06/14  00:08:48  Rhialto
; DICE conversion
;
	    include	"c.i"
;;;;
;
;   Some constants that need to be modified on specific versions

RTPRI	    equ 	0

;;;;
;
; The first executable location. This should return an error in case
; someone tried to run you as a program (instead of loading you as a
; device)

	section text,code

	moveq.l #20,d0
	rts

;;;;
;
; A romtag structure. Both "exec" and "ramlib" look for this structure to
; discover magic constants about you (such as where to start running you
; from...).
;
	xref	_DevName
	xref	_idString
	xref	@Init
	xdef	_RomTag
_RomTag:
	dc.w	$4AFC		; RTC_MATCHWORD
	dc.l	_RomTag 	; rt_MatchTag
	dc.l	EndCode 	; rt_EndSkip
	dc.b	0		; rt_Flags (no RTF_AUTOINIT)
	dc.b	VERSION 	; rt_Version
	dc.b	3		; rt_Type  NT_DEVICE
	dc.b	RTPRI		; rt_Pri
	dc.l	_DevName	; rt_Name
	dc.l	_idString	; rt_IdString
	dc.l	@Init		; rt_Init

;;;;
;
; Here begin the system interface commands. When the user calls
; OpenDevice/CloseDevice/RemDevice, this eventually gets trahslated into
; a call to the following routines (Open/Close/Expunge).  Exec has
; already put our device pointer in A6 for us.	Exec has turned off task
; switching while in these routines (via Forbid/Permit), so we should not
; take too long in them.
;
; These glue routines are not necessary when using the special
; __D0 keywords of DICE. When we do use these, don't forget to make sure
; the C routines expect the arguments on the stack (i.e. __stkargs)

	ifne	0
	xdef	__Init
	xref	_Init
__Init: 			;a0=segment list
	move.l	A0,-(sp)
	jsr	_Init
	addq	#4,sp
	rts

	xdef	__DevOpen
	xref	_DevOpen
__DevOpen:			;d0=unitnum,d1=flags,a1=ioreq,a6=device
	movem.l D0-D1/A1/A6,-(sp)
	jsr	_DevOpen
	lea	16(sp),sp
	rts

	xdef	__DevClose
	xref	_DevClose
__DevClose:			;a1=ioreq,a6=device
	movem.l A1/A6,-(sp)
	jsr	_DevClose
	addq	#8,sp
	rts

	xdef	__DevExpunge
	xref	_DevExpunge
__DevExpunge:			;a6=device
	movem.l A6,-(sp)
	jsr	_DevExpunge
	addq	#4,sp
	rts

	xdef	__DevBeginIO
	xref	_DevBeginIO
__DevBeginIO:			;a1=ioreq,a6=device
	movem.l A1/A6,-(sp)
	jsr	_DevBeginIO
	addq	#8,sp
	rts

	xdef	__DevAbortIO
	xref	_DevAbortIO
__DevAbortIO:			;a1=ioreq,a6=device
	movem.l A1/A6,-(sp)
	jsr	_DevAbortIO
	addq	#8,sp
	rts
	endc

	xdef	__LibNull
	xref	_LibNull
__LibNull:
	clr.l	d0
	rts


;#ifdef HANDLE_IO_QUICK
	ifne	HANDLE_IO_QUICK
;;;;
;
;   C interface to the atomic set bit and test old value instruction.
;
;   Called as	BSET_ACTIVE(byte *address).
;
;   Old value of the bit returned all over d0.w

	xdef	_BSET_ACTIVE
	xdef	@BSET_ACTIVE
_BSET_ACTIVE:
	move.l	4(sp),a0
@BSET_ACTIVE:
	bset	#UNITB_ACTIVE,(a0)         ; 0 UNITB_ACTIVE
	sne	d0
	rts
	endc

EndCode
	end
