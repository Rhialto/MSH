/*
 * $Id: mkci.c,v 1.54 1993/06/24 04:56:00 Rhialto Exp $
 * $Log: mkci.c,v $
 * Revision 1.54  1993/06/24  04:56:00	Rhialto
 * DICE 2.07.54R.
 *
 * Revision 1.53  92/10/25  02:19:07  Rhialto
 * Add some symbols.
 *
 * Revision 1.51  92/04/17  16:13:00  Rhialto
 * Freeze for MAXON3.
 *
 * Revision 1.46  91/10/06  18:24:25  Rhialto
 *
 * Freeze for MAXON
 *
 * Revision 1.43  91/09/28  01:53:37  Rhialto
 * *** empty log message ***
 *
 * MKCI.C
 *
 * Generate c.i file for assembly parts to export stuff from C to ASM level.
 */

#include "device.h"
#include "layout.h"
#include <exec/resident.h>
#include <stdio.h>

#define OFFSETOF(tag, member)   ((long)(&((struct tag *)0)->member))
#define OFFSET(label, structure, member) \
	printf("%s\tEQU %d\n", label, OFFSETOF(structure, member))
#define VALUE(label, value) \
	printf("%s\tEQU %d\n", label, value)

/* Grr.. Dice does't ge t the following right... */
#define DEFINE(label)   \
	printf(#label "\tEQU %d\n", label)


long
log2(unsigned long x)
{
    long log;

    if (x) {
	for (log = -1; x; log++)
	    x >>= 1;

	return log;
    } else {
	return -1;
    }
}

main(argc, argv)
int argc;
char **argv;
{
    if (argc > 1)
	freopen(argv[1], "w", stdout);

    printf("; Generated by $Id: mkci.c,v 1.54 1993/06/24 04:56:00 Rhialto Exp $\n; Don't edit by hand!\n");

    OFFSET("md_Rawbuffer", MessyDevice, md_Rawbuffer);
    OFFSET("md_MfmDecode", MessyDevice, md_MfmDecode[0]);
    VALUE("md_SIZEOF", sizeof(struct MessyDevice));

    OFFSET("mu_TrackBuffer", MessyUnit, mu_TrackBuffer);
    OFFSET("mu_CrcBuffer", MessyUnit, mu_CrcBuffer[0]);
    OFFSET("mu_SectorStatus", MessyUnit, mu_SectorStatus[0]);
    OFFSET("mu_InitSectorStatus", MessyUnit, mu_InitSectorStatus);
    OFFSET("mu_CurrentTrack", MessyUnit, mu_CurrentTrack);
    VALUE("MS_NSIDES", MS_NSIDES);
    VALUE("LOG2_MS_NSIDES", log2(MS_NSIDES));
    OFFSET("mu_CurrentSectors", MessyUnit, mu_CurrentSectors);
    OFFSET("mu_ReadLen", MessyUnit, mu_ReadLen);
    OFFSET("mu_WriteLen", MessyUnit, mu_WriteLen);

#ifdef READONLY
    VALUE("READONLY", 1);
#else
    VALUE("READONLY", 0);
#endif
#ifdef HANDLE_IO_QUICK
    VALUE("HANDLE_IO_QUICK", 1);
#else
    VALUE("HANDLE_IO_QUICK", 0);
#endif
    VALUE("UNITB_ACTIVE", UNITB_ACTIVE);
    VALUE("MS_BPS", MS_BPS);
    VALUE("MS_BPScode", log2(MS_BPS / 128));
    VALUE("LOG2_MS_BPS", log2(MS_BPS));
    VALUE("MS_SPT", MS_SPT);
    VALUE("MS_SPT_MAX", MS_SPT_MAX);
    VALUE("VERSION", VERSION);
    VALUE("REVISION", REVISION);

    /* Some system include values: */
    VALUE("RTC_MATCHWORD", RTC_MATCHWORD);
    VALUE("RTF_AUTOINIT", RTF_AUTOINIT);
    VALUE("NT_DEVICE", NT_DEVICE);
    VALUE("LIBF_CHANGED", LIBF_CHANGED);
    VALUE("LIBF_SUMUSED", LIBF_SUMUSED);

    OFFSET("ln_Type", Node, ln_Type);
    OFFSET("ln_Name", Node, ln_Name);
    OFFSET("dev_Flags", MessyDevice, dev_Flags);
    OFFSET("dev_Version", MessyDevice, dev_Version);
    OFFSET("dev_Revision", MessyDevice, dev_Revision);
    OFFSET("dev_IdString", MessyDevice, dev_IdString);
/*
:.+1,$s/DEFINE(\(.*\));/VALUE("\1", \1);/
*/
    VALUE("INDEXSYNC", INDEXSYNC);
    VALUE("SYNC", SYNC);
    VALUE("TLEN", TLEN);

    VALUE("INDEXGAP", INDEXGAP);
    VALUE("INDXGAP", INDXGAP);
    VALUE("INDXSYNC", INDXSYNC);
    VALUE("INDXMARK", INDXMARK);
    VALUE("INDEXGAP2", INDEXGAP2);

    VALUE("IDGAP2", IDGAP2);
    VALUE("IDSYNC", IDSYNC);
    VALUE("IDMARK", IDMARK);
    VALUE("IDDATA", IDDATA);
    VALUE("IDCRC", IDCRC);

    VALUE("DATAGAP1", DATAGAP1);
    VALUE("DATAGAP2", DATAGAP2);
    VALUE("DATASYNC", DATASYNC);
    VALUE("DATAMARK", DATAMARK);
    VALUE("DATACRC", DATACRC);

    return 0;
}

