/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : Olaf Seibert
 */

#include <exec/types.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <string.h>
#include "setwindow.h"

struct Screen	      *Scr = NULL;
UBYTE		      *PubScreenName = NULL;
APTR		       VisualInfo = NULL;
struct Window	      *MSHSettingsWnd = NULL;
struct Gadget	      *MSHSettingsGList = NULL;
struct Menu	      *MSHSettingsMenus = NULL;
UWORD		       MSHSettingsZoom[4];
struct Gadget	      *MSHSettingsGadgets[8];
UWORD		       MSHSettingsLeft = 10;
UWORD		       MSHSettingsTop = 14;
UWORD		       MSHSettingsWidth = 447;
UWORD		       MSHSettingsHeight = 92;
UBYTE		      *MSHSettingsWdt = (UBYTE *)"MSH Settings";
struct TextAttr       *Font, Attr;
UWORD		       FontX, FontY;
UWORD		       OffX, OffY;

UBYTE *CONVERSION0Labels[] = {
	(UBYTE *)"None",
	(UBYTE *)"A: PC Ascii",
	(UBYTE *)"B: ST Ascii",
	NULL };

struct NewMenu MSHSettingsNewMenu[] = {
	NM_TITLE, (STRPTR)"Project", NULL, 0, NULL, NULL,
	NM_ITEM, (STRPTR)"Hide", (STRPTR)"H", NM_ITEMDISABLED, 0L, NULL,
	NM_ITEM, (STRPTR)"Quit", (STRPTR)"Q", 0, 0L, NULL,
	NM_END, NULL, NULL, 0, 0L, NULL };

UWORD MSHSettingsGTypes[] = {
	CHECKBOX_KIND,
	CHECKBOX_KIND,
	CHECKBOX_KIND,
	CHECKBOX_KIND,
	CHECKBOX_KIND,
	CYCLE_KIND,
	BUTTON_KIND,
	LISTVIEW_KIND
};

struct NewGadget MSHSettingsNGad[] = {
	206, 19, 26, 11, (UBYTE *)"Check JUMP in bootblock", NULL, GD_BOOTJMP, PLACETEXT_RIGHT, NULL, NULL,
	206, 5, 26, 11, (UBYTE *)"40 track mode", NULL, GD_MD40TRACK, PLACETEXT_RIGHT, NULL, NULL,
	222, 47, 26, 11, (UBYTE *)"Check bootblock sanity", NULL, GD_SANITY, PLACETEXT_RIGHT, NULL, NULL,
	238, 61, 26, 11, (UBYTE *)"Not sane -> defaults", NULL, GD_SAN_DEFAULT, PLACETEXT_RIGHT, NULL, NULL,
	206, 33, 26, 11, (UBYTE *)"Always default bootblock", NULL, GD_USE_DEFAULT, PLACETEXT_RIGHT, NULL, NULL,
	33, 75, 121, 12, (UBYTE *)"Default conversion", NULL, GD_CONVERSION, PLACETEXT_ABOVE, NULL, NULL,
	171, 75, 57, 12, (UBYTE *)"Load", NULL, GD_LOAD, PLACETEXT_IN, NULL, NULL,
	16, 19, 158, 40, (UBYTE *)"Available handlers", NULL, GD_HANDLERS, PLACETEXT_ABOVE, NULL, NULL
};

ULONG MSHSettingsGTags[] = {
	(GTCB_Checked), TRUE, (TAG_DONE),
	(TAG_DONE),
	(GTCB_Checked), TRUE, (TAG_DONE),
	(GTCB_Checked), TRUE, (TAG_DONE),
	(TAG_DONE),
	(GTCY_Labels), (ULONG)&CONVERSION0Labels[ 0 ], (TAG_DONE),
	(TAG_DONE),
	(GTLV_ShowSelected), NULL, (TAG_DONE)
};

static UWORD ComputeX( UWORD value )
{
	return(( UWORD )((( FontX * value ) + 4 ) / 8 ));
}

static UWORD ComputeY( UWORD value )
{
	return(( UWORD )((( FontY * value ) + 4 ) / 8 ));
}

static void ComputeFont( UWORD width, UWORD height )
{
	Font = &Attr;
	Font->ta_Name = (STRPTR)Scr->RastPort.Font->tf_Message.mn_Node.ln_Name;
	Font->ta_YSize = FontY = Scr->RastPort.Font->tf_YSize;
	FontX = Scr->RastPort.Font->tf_XSize;

	OffX = Scr->WBorLeft;
	OffY = Scr->RastPort.TxHeight + Scr->WBorTop + 1;

	if ( width && height ) {
		if (( ComputeX( width ) + OffX + Scr->WBorRight ) > Scr->Width )
			goto UseTopaz;
		if (( ComputeY( height ) + OffY + Scr->WBorBottom ) > Scr->Height )
			goto UseTopaz;
	}
	return;

UseTopaz:
	Font->ta_Name = (STRPTR)"topaz.font";
	FontX = FontY = Font->ta_YSize = 8;
}

int SetupScreen( void )
{
	if ( ! ( Scr = LockPubScreen( PubScreenName )))
		return( 1L );

	ComputeFont( 0, 0 );

	if ( ! ( VisualInfo = GetVisualInfo( Scr, TAG_DONE )))
		return( 2L );

	return( 0L );
}

void CloseDownScreen( void )
{
	if ( VisualInfo ) {
		FreeVisualInfo( VisualInfo );
		VisualInfo = NULL;
	}

	if ( Scr        ) {
		UnlockPubScreen( NULL, Scr );
		Scr = NULL;
	}
}

int OpenMSHSettingsWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft = MSHSettingsLeft, wtop = MSHSettingsTop, ww, wh;

	ComputeFont( MSHSettingsWidth, MSHSettingsHeight );

	ww = ComputeX( MSHSettingsWidth );
	wh = ComputeY( MSHSettingsHeight );

	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( g = CreateContext( &MSHSettingsGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < MSHSettings_CNT; lc++ ) {

		CopyMem((char * )&MSHSettingsNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr	 = Font;
		ng.ng_LeftEdge	 = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge	 = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width	 = ComputeX( ng.ng_Width );
		ng.ng_Height	 = ComputeY( ng.ng_Height);

		MSHSettingsGadgets[ lc ] = g = CreateGadgetA((ULONG)MSHSettingsGTypes[ lc ], g, &ng, ( struct TagItem * )&MSHSettingsGTags[ tc ] );

		while( MSHSettingsGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( MSHSettingsMenus = CreateMenus( MSHSettingsNewMenu, GTMN_FrontPen, 0L, TAG_DONE )))
		return( 3L );

	LayoutMenus( MSHSettingsMenus, VisualInfo, TAG_DONE );

	MSHSettingsZoom[0] = MSHSettingsLeft;
	MSHSettingsZoom[1] = MSHSettingsTop;
	if ( MSHSettingsWdt )
		MSHSettingsZoom[2] = TextLength( &Scr->RastPort, (UBYTE *)MSHSettingsWdt, strlen((char *)MSHSettingsWdt )) + 80;
	else
		MSHSettingsZoom[2]  = 80L;
		MSHSettingsZoom[3] = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

	if ( ! ( MSHSettingsWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				WA_Top, 	wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	CHECKBOXIDCMP|CYCLEIDCMP|BUTTONIDCMP|LISTVIEWIDCMP|IDCMP_MENUPICK|IDCMP_CLOSEWINDOW|IDCMP_DISKINSERTED|IDCMP_DISKREMOVED|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE,
				WA_Gadgets,	MSHSettingsGList,
				WA_Title,	MSHSettingsWdt,
				WA_ScreenTitle, "MSH Settings",
				WA_PubScreen,	Scr,
				WA_Zoom,	MSHSettingsZoom,
				WA_AutoAdjust,	TRUE,
				TAG_DONE )))
	return( 4L );

	SetMenuStrip( MSHSettingsWnd, MSHSettingsMenus );
	GT_RefreshWindow( MSHSettingsWnd, NULL );

	return( 0L );
}

void CloseMSHSettingsWindow( void )
{
	if ( MSHSettingsMenus      ) {
		ClearMenuStrip( MSHSettingsWnd );
		FreeMenus( MSHSettingsMenus );
		MSHSettingsMenus = NULL;	}

	if ( MSHSettingsWnd        ) {
		CloseWindow( MSHSettingsWnd );
		MSHSettingsWnd = NULL;
	}

	if ( MSHSettingsGList      ) {
		FreeGadgets( MSHSettingsGList );
		MSHSettingsGList = NULL;
	}
}

