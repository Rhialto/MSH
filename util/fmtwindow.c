/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : Olaf 'Rhialto' Seibert
 */

#include <exec/types.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <string.h>
#include "fmtwindow.h"

struct Screen         *Scr = NULL;
UBYTE                 *PubScreenName = NULL;
APTR                   VisualInfo = NULL;
struct Window         *MainWnd = NULL;
struct Window         *ParmWnd = NULL;
struct Gadget         *MainGList = NULL;
struct Gadget         *ParmGList = NULL;
UWORD                  MainZoom[4];
UWORD                  ParmZoom[4];
struct Gadget         *MainGadgets[5];
struct Gadget         *ParmGadgets[14];
UWORD                  MainLeft = 28;
UWORD                  MainTop = 19;
UWORD                  MainWidth = 420;
UWORD                  MainHeight = 88;
UWORD                  ParmLeft = 11;
UWORD                  ParmTop = 19;
UWORD                  ParmWidth = 522;
UWORD                  ParmHeight = 129;
UBYTE                 *MainWdt = (UBYTE *)"MSH Format";
UBYTE                 *ParmWdt = (UBYTE *)"MSH Format Parameters";
struct TextAttr       *Font, Attr;
UWORD                  FontX, FontY;
UWORD                  OffX, OffY;

UBYTE *FMT_WHAT0Labels[] = {
	(UBYTE *)"Bootblock only",
	(UBYTE *)"Bootblock + root dir",
	(UBYTE *)"Format whole disk",
	NULL };

UWORD MainGTypes[] = {
	LISTVIEW_KIND,
	MX_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND
};

UWORD ParmGTypes[] = {
	STRING_KIND,
	STRING_KIND,
	STRING_KIND,
	STRING_KIND,
	STRING_KIND,
	STRING_KIND,
	STRING_KIND,
	STRING_KIND,
	STRING_KIND,
	STRING_KIND,
	STRING_KIND,
	STRING_KIND,
	STRING_KIND,
	BUTTON_KIND
};

struct NewGadget MainNGad[] = {
	13, 18, 174, 64, (UBYTE *)"Format device:", NULL, GD_HANDLERS, PLACETEXT_ABOVE, NULL, NULL,
	211, 7, 17, 9, NULL, NULL, GD_FMT_WHAT, PLACETEXT_RIGHT, NULL, NULL,
	211, 44, 91, 16, (UBYTE *)"Options", NULL, GD_OPTIONS, PLACETEXT_IN, NULL, NULL,
	211, 66, 91, 16, (UBYTE *)"Format", NULL, GD_DOIT, PLACETEXT_IN, NULL, NULL,
	314, 66, 91, 16, (UBYTE *)"Cancel", NULL, GD_CANCEL, PLACETEXT_IN, NULL, NULL
};

struct NewGadget ParmNGad[] = {
	7, 3, 53, 13, (UBYTE *)"Bytes per sector", NULL, GD_BPS, PLACETEXT_RIGHT, NULL, NULL,
	7, 18, 53, 13, (UBYTE *)"Sectors per track", NULL, GD_SPT, PLACETEXT_RIGHT, NULL, NULL,
	7, 33, 53, 13, (UBYTE *)"Number of sides", NULL, GD_NSIDES, PLACETEXT_RIGHT, NULL, NULL,
	7, 48, 53, 13, (UBYTE *)"Starting cylinder", NULL, GD_FIRSTCYL, PLACETEXT_RIGHT, NULL, NULL,
	7, 63, 53, 13, (UBYTE *)"Number of cylinders", NULL, GD_NCYLS, PLACETEXT_RIGHT, NULL, NULL,
	7, 78, 53, 13, (UBYTE *)"Boot sectors", NULL, GD_RESERVED, PLACETEXT_RIGHT, NULL, NULL,
	7, 93, 53, 13, (UBYTE *)"Number of hidden sectors", NULL, GD_NHID, PLACETEXT_RIGHT, NULL, NULL,
	273, 3, 53, 13, (UBYTE *)"Sectors per cluster", NULL, GD_SPC, PLACETEXT_RIGHT, NULL, NULL,
	273, 18, 53, 13, (UBYTE *)"Number of FAT copies", NULL, GD_NFATS, PLACETEXT_RIGHT, NULL, NULL,
	273, 33, 53, 13, (UBYTE *)"Sectors per FAT", NULL, GD_SPF, PLACETEXT_RIGHT, NULL, NULL,
	273, 48, 53, 13, (UBYTE *)"Total number of sectors", NULL, GD_NSECTS, PLACETEXT_RIGHT, NULL, NULL,
	273, 78, 53, 13, (UBYTE *)"Media byte", NULL, GD_MEDIA, PLACETEXT_RIGHT, NULL, NULL,
	273, 93, 53, 13, (UBYTE *)"Root directory entries", NULL, GD_NDIRS, PLACETEXT_RIGHT, NULL, NULL,
	8, 109, 504, 16, (UBYTE *)"OK", NULL, GD_OK, PLACETEXT_IN, NULL, NULL
};

ULONG MainGTags[] = {
	(GTLV_ShowSelected), NULL, (TAG_DONE),
	(GTMX_Labels), (ULONG)&FMT_WHAT0Labels[ 0 ], (GTMX_Spacing), 3, (TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE)
};

ULONG ParmGTags[] = {
	(GTST_MaxChars), 16, (TAG_DONE),
	(GTST_MaxChars), 16, (TAG_DONE),
	(GTST_MaxChars), 16, (TAG_DONE),
	(GTST_MaxChars), 16, (TAG_DONE),
	(GTST_MaxChars), 16, (TAG_DONE),
	(GTST_MaxChars), 16, (TAG_DONE),
	(GTST_MaxChars), 16, (TAG_DONE),
	(GTST_MaxChars), 16, (TAG_DONE),
	(GTST_MaxChars), 16, (TAG_DONE),
	(GTST_MaxChars), 16, (TAG_DONE),
	(GTST_MaxChars), 16, (TAG_DONE),
	(GTST_MaxChars), 16, (TAG_DONE),
	(GTST_MaxChars), 16, (TAG_DONE),
	(TAG_DONE)
};

static UWORD ComputeX( UWORD value )
{
	return(( UWORD )((( FontX * value ) + 4 ) / 8 ));
}

static UWORD ComputeY( UWORD value )
{
	return(( UWORD )((( FontY * value ) + 4 ) / 8 ));
}

static void ComputeFont( UWORD width, UWORD height )
{
	Font = &Attr;
	Font->ta_Name = (STRPTR)Scr->RastPort.Font->tf_Message.mn_Node.ln_Name;
	Font->ta_YSize = FontY = Scr->RastPort.Font->tf_YSize;
	FontX = Scr->RastPort.Font->tf_XSize;

	OffX = Scr->WBorLeft;
	OffY = Scr->RastPort.TxHeight + Scr->WBorTop + 1;

	if ( width && height ) {
		if (( ComputeX( width ) + OffX + Scr->WBorRight ) > Scr->Width )
			goto UseTopaz;
		if (( ComputeY( height ) + OffY + Scr->WBorBottom ) > Scr->Height )
			goto UseTopaz;
	}
	return;

UseTopaz:
	Font->ta_Name = (STRPTR)"topaz.font";
	FontX = FontY = Font->ta_YSize = 8;
}

int SetupScreen( void )
{
	if ( ! ( Scr = LockPubScreen( PubScreenName )))
		return( 1L );

	ComputeFont( 0, 0 );

	if ( ! ( VisualInfo = GetVisualInfo( Scr, TAG_DONE )))
		return( 2L );

	return( 0L );
}

void CloseDownScreen( void )
{
	if ( VisualInfo ) {
		FreeVisualInfo( VisualInfo );
		VisualInfo = NULL;
	}

	if ( Scr        ) {
		UnlockPubScreen( NULL, Scr );
		Scr = NULL;
	}
}

int OpenMainWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft = MainLeft, wtop = MainTop, ww, wh;

	ComputeFont( MainWidth, MainHeight );

	ww = ComputeX( MainWidth );
	wh = ComputeY( MainHeight );

	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( g = CreateContext( &MainGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < Main_CNT; lc++ ) {

		CopyMem((char * )&MainNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = Font;
		ng.ng_LeftEdge   = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge    = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width      = ComputeX( ng.ng_Width );
		ng.ng_Height     = ComputeY( ng.ng_Height);

		MainGadgets[ lc ] = g = CreateGadgetA((ULONG)MainGTypes[ lc ], g, &ng, ( struct TagItem * )&MainGTags[ tc ] );

		while( MainGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	MainZoom[0] = MainLeft;
	MainZoom[1] = MainTop;
	if ( MainWdt )
		MainZoom[2] = TextLength( &Scr->RastPort, (UBYTE *)MainWdt, strlen((char *)MainWdt )) + 80;
	else
		MainZoom[2]  = 80L;
		MainZoom[3] = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

	if ( ! ( MainWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				WA_Top,		wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	LISTVIEWIDCMP|MXIDCMP|BUTTONIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH,
				WA_Gadgets,	MainGList,
				WA_Title,	MainWdt,
				WA_ScreenTitle,	"MSH Format",
				WA_PubScreen,	Scr,
				WA_Zoom,	MainZoom,
				WA_AutoAdjust,	TRUE,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( MainWnd, NULL );

	return( 0L );
}

void CloseMainWindow( void )
{
	if ( MainWnd        ) {
		CloseWindow( MainWnd );
		MainWnd = NULL;
	}

	if ( MainGList      ) {
		FreeGadgets( MainGList );
		MainGList = NULL;
	}
}

int OpenParmWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft = ParmLeft, wtop = ParmTop, ww, wh;

	ComputeFont( ParmWidth, ParmHeight );

	ww = ComputeX( ParmWidth );
	wh = ComputeY( ParmHeight );

	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( g = CreateContext( &ParmGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < Parm_CNT; lc++ ) {

		CopyMem((char * )&ParmNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = Font;
		ng.ng_LeftEdge   = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge    = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width      = ComputeX( ng.ng_Width );
		ng.ng_Height     = ComputeY( ng.ng_Height);

		ParmGadgets[ lc ] = g = CreateGadgetA((ULONG)ParmGTypes[ lc ], g, &ng, ( struct TagItem * )&ParmGTags[ tc ] );

		while( ParmGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	ParmZoom[0] = ParmLeft;
	ParmZoom[1] = ParmTop;
	if ( ParmWdt )
		ParmZoom[2] = TextLength( &Scr->RastPort, (UBYTE *)ParmWdt, strlen((char *)ParmWdt )) + 80;
	else
		ParmZoom[2]  = 80L;
		ParmZoom[3] = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

	if ( ! ( ParmWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				WA_Top,		wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	STRINGIDCMP|BUTTONIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH,
				WA_Gadgets,	ParmGList,
				WA_Title,	ParmWdt,
				WA_ScreenTitle,	"MSH Format",
				WA_PubScreen,	Scr,
				WA_Zoom,	ParmZoom,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( ParmWnd, NULL );

	return( 0L );
}

void CloseParmWindow( void )
{
	if ( ParmWnd        ) {
		CloseWindow( ParmWnd );
		ParmWnd = NULL;
	}

	if ( ParmGList      ) {
		FreeGadgets( ParmGList );
		ParmGList = NULL;
	}
}

